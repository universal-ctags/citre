;;; citre-basic-tools.el --- Integration of Citre with Emacs built-in tools -*- lexical-binding: t -*-

;; Copyright (C) 2020 Hao Wang

;; Author: Hao Wang <amaikinono@gmail.com>
;; Maintainer: Hao Wang <amaikinono@gmail.com>
;; Created: 23 Nov 2020
;; Keywords: convenience, tools
;; Homepage: https://github.com/AmaiKinono/citre
;; Version: 0

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 3
;; of the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; Code:

;; To see the outline of this file, run M-x outline-minor-mode and
;; then press C-c @ C-t. To also show the top-level functions and
;; variable declarations in each section, run M-x occur with the
;; following query: ^;;;;* \|^(

;;;; Libraries

(require 'citre-util)
(require 'ring)
(require 'subr-x)

;;;; User options

;;;;; Options: Enabled tools

(defcustom citre-enable-xref-integration t
  "Enable xref integration."
  :type 'boolean
  :group 'citre)

(make-variable-buffer-local 'citre-enable-xref-integration)

(defcustom citre-enable-capf-integration t
  "Enable auto-completion by `completion-at-point'."
  :type 'boolean
  :group 'citre)

(make-variable-buffer-local 'citre-enable-capf-integration)

;;;;; Options: `citre-jump' related

(defcustom citre-select-location-function
  #'citre-select-location-completing-read
  "The function for the user to select a location from a list.
It accepts a list of one or more strings, and returns one of
them.  This is used for `citre-jump'.

The strings are generated by `citre-make-location-str', and the
function should let the user choose one in it.  The list is
guaranteed to have one or more elements.  When there are only one
element, the function can decide to let the user confirm, or
return it directly.

See `citre-select-location-completing-read' for an example of
implementation."
  :type 'function
  :group 'citre)

;;;;; Options: capf related

(defcustom citre-capf-substr-completion nil
  "Whether do substring completion.
Non-nil means to match tags *containing* the symbol to be
completed, Otherwise match tags *start with* the symbol to be
completed.

Notice that when listing the candidates, Emacs itself will
further filter the completions we supply, and its behavior is
controlled by `completion-styles'.  If you want substring
completion, you need to set `citre-capf-substr-completion' to
non-nil, *and* add `substring' to `completion-styles' (for Emacs
27, there is also a `flex' style that will work)."
  :type 'boolean
  :group 'citre)

(defcustom citre-completion-in-region-function
  #'citre-completion-in-region
  "The function used for `completion-in-region-function'.
This is called by `completion-at-point' in buffers where Citre
mode is enabled, and offers an alternative UI for completion.

When nil, don't modify `completion-in-region-function'."
  :type '(choice function (const :tag "Default" nil))
  :group 'citre)

;;;; Tool: Xref integration

(declare-function xref-make "xref" (summary location))
(declare-function xref-make-file-location "xref" (file line column))

;; NOTE: In the worst situation, this will create and kill a temporary buffer
;; when processing every record.  If we get bug report on the performance, we
;; could use the temp buffer technique in citre-peek, so we only need to do
;; this once for every file.
(defun citre-xref--get-linum (record)
  "Get the line number of tag RECORD.
If there's no buffer visiting the file containing the tag, this
openes it temporarily, and clean it up on exit.

When the file pointed to by RECORD doesn't exist, this returns
the line number in RECORD, or 0 if it doesn't record the line
number.  This is because we don't want to fail an xref session
only because one file is lost, and users may manually use the
line number if they know the file is renamed/moved to which
file."
  (let* ((path (citre-core-get-field 'ext-abspath record))
         (buf-opened (find-buffer-visiting path))
         buf linum)
    (if (not (file-exists-p path))
        (or (citre-core-get-field 'extra-line record) 0)
      (if buf-opened
          (setq buf buf-opened)
        (setq buf (generate-new-buffer (format " *citre-xref-%s*" path)))
        (with-current-buffer buf
          (insert-file-contents path)))
      (with-current-buffer buf
        (setq linum (citre-core-locate-tag record 'use-linum)))
      (unless buf-opened
        (kill-buffer buf))
      linum)))

(defun citre-xref--make-object (record)
  "Make xref object of RECORD."
  (let* ((kind (citre-core-get-field 'kind record))
         (kind (if kind
                   (concat (propertize kind 'face 'warning) " ")
                 ""))
         (path (citre-core-get-field 'ext-abspath record))
         (file-existance
          (if (file-exists-p path) "" "*missing*"))
         (line (citre-xref--get-linum record))
         (str (citre-core-get-field 'extra-matched-str record)))
    (xref-make
     (concat kind str)
     (xref-make-file-location (concat file-existance path) line 0))))

(defun citre-xref--find-definition (symbol)
  "Return the xref object of the definition information of SYMBOL."
  (mapcar #'citre-xref--make-object
          (citre-get-definitions nil symbol)))

(defun citre-xref-backend ()
  "Define the Citre backend for xref."
  'citre)

(cl-defmethod xref-backend-identifier-at-point ((_backend (eql citre)))
  "Define method for xref to get symbol at point."
  (citre-get-symbol))

(cl-defmethod xref-backend-definitions ((_backend (eql citre)) symbol)
  "Define method for xref to find definition of SYMBOL."
  (citre-xref--find-definition symbol))

(cl-defmethod xref-backend-identifier-completion-table
  ((_backend (eql citre)))
  "Return a function for xref to find all completions of a prefix."
  (lambda (str pred action)
    (let ((collection
           (mapcar (lambda (record) (citre-core-get-field 'name record))
                   (citre-get-records nil "" nil :require '(name)))))
      (complete-with-action action collection str pred))))

;;;; Tool: `citre-jump'

;;;;; Internals

(defvar citre--marker-ring (make-ring 50)
  "The marker ring used by `citre-jump'.")

(defun citre-select-location-completing-read (locations)
  "Select an element in LOCATIONS.
This uses the `completing-read' interface.  See
`citre-select-location-function' for the use of this function."
  (pcase (length locations)
    (1 (car locations))
    (_ (completing-read "location: " locations nil t))))

;;;;; Commands

(defun citre-jump ()
  "Jump to the definition of the symbol at point.
During an active `citre-peek' session, this jumps to the
definition that is currently peeked."
  (interactive)
  (let ((marker (point-marker))
        (target nil))
    (let* ((locations (mapcar #'citre-make-location-str
                              (citre-get-definitions)))
           (loc-alist (mapcar (lambda (loc)
                                (cons loc
                                      (citre-get-property
                                       loc nil 'from-record)))
                              locations)))
      (if (null locations)
          (user-error "Can't find definition")
        (setq target (funcall citre-select-location-function locations))
        (citre-goto-tag (alist-get target loc-alist nil nil #'equal))))
    (ring-insert citre--marker-ring marker)))

(defun citre-jump-back ()
  "Go back to the position before last `citre-jump'."
  (interactive)
  (let ((ring citre--marker-ring))
    (when (ring-empty-p ring)
      (user-error "No more previous history"))
    (let ((marker (ring-remove ring 0)))
      (switch-to-buffer
       (or (marker-buffer marker)
           (user-error "The previous buffer has been deleted")))
      (goto-char (marker-position marker))
      (set-marker marker nil)
      (run-hooks 'citre-after-jump-hook))))

;;;; Tool: Capf integration

;;;;; Internals

(defvar-local citre-completion-in-region-function-orig nil
  "This stores the original `completion-in-region-function'.
This is only set when `completion-in-region-function' is
originally buffer-local.")

;; TODO: remove this. I believe most "completion framework" handles this (at
;; least ivy/selectrum do), and users rely on auto-completion may be using
;; auto-completion.el/company. But let's do this after we create a nice
;; auto-completion tool for vanilla Emacs users.
(defun citre-completion-in-region (start end collection &optional predicate)
  "A function replacing the default `completion-in-region-function'.
This completes the text between START and END using COLLECTION.
PREDICATE says when to exit.

When there are multiple candidates, this uses the standard
`completing-read' interface, while the default
`completion--in-region' pops a *Completions* buffer to show them.
When combined with some minibuffer completion framework, this is
more user-friendly then the default one.

Notice when `completing-read-function' is
`completing-read-default' (i.e., not enhanced by a minibuffer
completion framework), this falls back to the default
`completion--in-region'."
  (if (eq completing-read-function #'completing-read-default)
      (completion--in-region start end collection predicate)
    (let* ((str (buffer-substring-no-properties start end))
           (completion-ignore-case (string= str (downcase str)))
           (candidates
            (nconc
             (completion-all-completions str collection predicate
                                         (- end start))
             nil))
           (completion nil))
      (pcase (length candidates)
        (0 (message "No completions"))
        (1 (setq completion (car candidates)))
        (_ (setq completion (completing-read (format "(%s): " str)
                                             candidates predicate t))))
      (when completion
        (delete-region start end)
        (insert (substring-no-properties completion))))))

(defun citre--make-completion-annotation (cand)
  "Generate annotation for a completion string CAND.
CAND is the returned value of `citre-make-completion-str'."
  (let* ((kind (citre-get-property cand 'ext-kind-full 'from-record))
         (type (citre-get-property cand 'typeref 'from-record))
         (type (when type (substring type (1+ (string-match ":" type))))))
    (when (or kind type)
      (propertize (concat
                   " ("
                   (or kind "")
                   (if (and kind type) "/" "")
                   (or type "")
                   ")")
                  ;; TODO: Maybe we should change this name?
                  'face 'citre-definition-annotation-face))))

;;;;; Entry point

(defun citre-completion-at-point ()
  "Function used for `completion-at-point-functions'."
  (when-let* ((symbol (citre-get-symbol))
              (bounds (citre-get-property symbol 'bounds))
              (start (car bounds))
              (end (cdr bounds))
              (collection
               (mapcar #'citre-make-completion-str
                       (citre-get-completions
                        symbol nil citre-capf-substr-completion)))
              (get-docsig
               (lambda (candidate)
                 (citre-get-property candidate 'signature 'from-record))))
    (list start end collection
          :annotation-function #'citre--make-completion-annotation
          :company-docsig get-docsig
          ;; This makes our completion function a "non-exclusive" one, which
          ;; means to try the next completion function when current completion
          ;; table fails to match the text at point (see the docstring of
          ;; `completion-at-point-functions').  This is the desired behavior
          ;; but actually it breaks our substring completion.  This is a bug of
          ;; Emacs, see the FIXME comment in the code of
          ;; `completion--capf-wrapper'.  I believe I've fixed it, so let's
          ;; leave this line commented rather than delete it, and see if my
          ;; patch will get itself into Emacs
          ;; (https://debbugs.gnu.org/cgi/bugreport.cgi?bug=39600).

          ;; It actually doesn't cause much inconvenience.  Our completion
          ;; function works well, and the only problem is it won't fallback to
          ;; the next one when no tags are matched, which I believe to also
          ;; happen in other completion functions.

          ;; :exclusive 'no
          )))

;;;; Tool: misc commands

(defun citre-show-project-root ()
  "Show the project root of current buffer.
Use this command to see if Citre detects the project root
correctly."
  (interactive)
  (if (citre-project-root)
      (message (citre-project-root))
    (user-error "Buffer is not in a project")))

;;;; Tool: Citre mode

;;;###autoload
(define-minor-mode citre-mode
  "Ctags IDE on the True Editor"
  :lighter " Citre"
  ;; TODO: At this time I don't know clealy if Citre mode needs to work in a
  ;; file.  If not, we could remove this, then for example you can set
  ;; `citre-project-root' in *scratch* buffer and test somethings in it.  Maybe
  ;; some users would want to do this.
  (cond
   (citre-mode
    ;; Xref integration.
    (when citre-enable-xref-integration
      (add-hook 'xref-backend-functions #'citre-xref-backend nil t))
    ;; Capf integration.
    (when citre-enable-capf-integration
      (add-hook 'completion-at-point-functions
                #'citre-completion-at-point nil t)
      ;; Set `completion-in-region-function'.
      (when citre-completion-in-region-function
        (when (local-variable-p 'completion-in-region-function)
          (setq citre-completion-in-region-function-orig
                completion-in-region-function))
        (set (make-local-variable 'completion-in-region-function)
             citre-completion-in-region-function))))
   (t
    (remove-hook 'xref-backend-functions #'citre-xref-backend t)
    (remove-hook 'completion-at-point-functions #'citre-completion-at-point t)
    (if citre-completion-in-region-function-orig
        (progn
          (setq completion-in-region-function
                citre-completion-in-region-function-orig)
          (setq citre-completion-in-region-function-orig nil))
      (kill-local-variable 'completion-in-region-function)))))

(provide 'citre-basic-tools)

;; Local Variables:
;; indent-tabs-mode: nil
;; outline-regexp: ";;;;* "
;; fill-column: 79
;; emacs-lisp-docstring-fill-column: 65
;; sentence-end-double-space: t
;; End:

;;; citre-basic-tools.el ends here
